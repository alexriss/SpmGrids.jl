<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · SpmGrids.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://alexriss.github.io/SpmGrids.jl/reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SpmGrids.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpmGrids.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial_1/">Tutorial 1: Basics</a></li><li><a class="tocitem" href="../tutorial_2/">Tutorial 2: Data manipulation</a></li><li><a class="tocitem" href="../tutorial_3/">Tutorial 3: Real life</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alexriss/SpmGrids.jl/blob/main/docs/src/reference.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><ul><li><a href="#Base.resize!-Tuple{SpmGrids.SpmGrid, Vararg{Any}}"><code>Base.resize!</code></a></li><li><a href="#SpmGrids.add_channel!-Tuple{SpmGrids.SpmGrid, AbstractString, AbstractString, AbstractArray{Float64}}"><code>SpmGrids.add_channel!</code></a></li><li><a href="#SpmGrids.add_channel!-Tuple{Function, SpmGrids.SpmGrid, AbstractString, AbstractString, Vararg{Any}}"><code>SpmGrids.add_channel!</code></a></li><li><a href="#SpmGrids.add_parameter!-Tuple{SpmGrids.SpmGrid, AbstractString, AbstractString, AbstractArray{Float64}}"><code>SpmGrids.add_parameter!</code></a></li><li><a href="#SpmGrids.add_parameter!-Tuple{Function, SpmGrids.SpmGrid, AbstractString, AbstractString, Vararg{Any}}"><code>SpmGrids.add_parameter!</code></a></li><li><a href="#SpmGrids.channel_names-Tuple{SpmGrids.SpmGrid}"><code>SpmGrids.channel_names</code></a></li><li><a href="#SpmGrids.deconvolve_force!"><code>SpmGrids.deconvolve_force!</code></a></li><li><a href="#SpmGrids.fit_KPFM!-Tuple{SpmGrids.SpmGrid, String}"><code>SpmGrids.fit_KPFM!</code></a></li><li><a href="#SpmGrids.get_channel"><code>SpmGrids.get_channel</code></a></li><li><a href="#SpmGrids.get_channel_unit-Tuple{SpmGrids.SpmGrid, AbstractString}"><code>SpmGrids.get_channel_unit</code></a></li><li><a href="#SpmGrids.get_data"><code>SpmGrids.get_data</code></a></li><li><a href="#SpmGrids.get_parameter"><code>SpmGrids.get_parameter</code></a></li><li><a href="#SpmGrids.get_parameter_unit-Tuple{SpmGrids.SpmGrid, AbstractString}"><code>SpmGrids.get_parameter_unit</code></a></li><li><a href="#SpmGrids.has_channel-Tuple{SpmGrids.SpmGrid, AbstractString}"><code>SpmGrids.has_channel</code></a></li><li><a href="#SpmGrids.has_parameter-Tuple{SpmGrids.SpmGrid, AbstractString}"><code>SpmGrids.has_parameter</code></a></li><li><a href="#SpmGrids.interactive_display"><code>SpmGrids.interactive_display</code></a></li><li><a href="#SpmGrids.interactive_display"><code>SpmGrids.interactive_display</code></a></li><li><a href="#SpmGrids.load_grid"><code>SpmGrids.load_grid</code></a></li><li><a href="#SpmGrids.load_grid"><code>SpmGrids.load_grid</code></a></li><li><a href="#SpmGrids.load_grid-Tuple{AbstractString}"><code>SpmGrids.load_grid</code></a></li><li><a href="#SpmGrids.parameter_names-Tuple{SpmGrids.SpmGrid}"><code>SpmGrids.parameter_names</code></a></li><li><a href="#SpmGrids.plot_cube"><code>SpmGrids.plot_cube</code></a></li><li><a href="#SpmGrids.plot_cube-Tuple{NamedTuple, Any, Any, Module}"><code>SpmGrids.plot_cube</code></a></li><li><a href="#SpmGrids.plot_line"><code>SpmGrids.plot_line</code></a></li><li><a href="#SpmGrids.plot_line-Tuple{NamedTuple, Any, Module}"><code>SpmGrids.plot_line</code></a></li><li><a href="#SpmGrids.plot_parameter_plane"><code>SpmGrids.plot_parameter_plane</code></a></li><li><a href="#SpmGrids.plot_plane-Tuple{NamedTuple, Any, Any, Module}"><code>SpmGrids.plot_plane</code></a></li><li><a href="#SpmGrids.plot_plane"><code>SpmGrids.plot_plane</code></a></li><li><a href="#SpmGrids.plot_spectrum"><code>SpmGrids.plot_spectrum</code></a></li><li><a href="#SpmGrids.point_to_xyindex-Tuple{SpmGrids.SpmGrid, Vector{Float64}}"><code>SpmGrids.point_to_xyindex</code></a></li><li><a href="#SpmGrids.xyindex_to_point-Tuple{SpmGrids.SpmGrid, Int64, Int64}"><code>SpmGrids.xyindex_to_point</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Base.resize!-Tuple{SpmGrids.SpmGrid, Vararg{Any}}" href="#Base.resize!-Tuple{SpmGrids.SpmGrid, Vararg{Any}}"><code>Base.resize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resize!(grid::SpmGrid, args...; kwargs...)</code></pre><p>Resizes the grid in its dimensions. Arguments and keyword-arguments are similar as for the <a href="@ref">ImageTransformations.imresize</a> function.</p><p>Examples:</p><pre><code class="language-julia hljs">julia&gt; resize!(grid, ratio=0.5)  # resize all dimensions by a factor 0.5
julia&gt; resize!(grid, ratio=(0.5, 0.5))  # resize x and y dimensions by a factor 0.5
julia&gt; resize!(grid, ratio=(0.5, 0.5, 2.0))  # resize x and y dimensions by a factor 0.5, z dimension by a factor of 2
julia&gt; resize!(grid, 64, 64)    # resize x and y dimensions to a specific pixelsize
julia&gt; resize!(grid, 32, 96, 128)   # resize all dimensions to a specific pixelsize</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L247-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.add_channel!-Tuple{Function, SpmGrids.SpmGrid, AbstractString, AbstractString, Vararg{Any}}" href="#SpmGrids.add_channel!-Tuple{Function, SpmGrids.SpmGrid, AbstractString, AbstractString, Vararg{Any}}"><code>SpmGrids.add_channel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_channel!(func::Function, grid::SpmGrid, name::AbstractString, unit::AbstractString,
    args...; skip_bwd::Bool=false, force::Bool=false)::Nothing</code></pre><p>Adds a generated channel with <code>name</code>, <code>unit</code> and <code>data</code> to the <code>grid</code>. The channel is generated by the function <code>func</code> that takes other channels/parameters specified by <code>args...</code> as input parameters. Any broadcasting functionality should be implemented in <code>func</code>. The <code>name</code> cannot be the same as names in the original channel names. If the <code>name</code> exists in the generated channel names, it will be overwritten. If <code>skip_bwd</code> is <code>false</code> (default), then bwd channels will be added if feasible. If <code>force</code> is <code>true</code>, then the consistency checks for name and dimensions are overriden.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; grid = load_grid(&quot;file.3ds&quot;)
julia&gt; add_channel!(x -&gt; abs(x), grid, &quot;CurrentAbs&quot;, &quot;A&quot;, &quot;Current&quot;)
julia&gt; add_channel!((x,y) -&gt; x + y, grid, &quot;&quot;, &quot;A&quot;, &quot;Current&quot;, &quot;AbsCurrent&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L475-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.add_channel!-Tuple{SpmGrids.SpmGrid, AbstractString, AbstractString, AbstractArray{Float64}}" href="#SpmGrids.add_channel!-Tuple{SpmGrids.SpmGrid, AbstractString, AbstractString, AbstractArray{Float64}}"><code>SpmGrids.add_channel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_channel!(grid::SpmGrid, name::AbstractString, unit::AbstractString,
    data::AbstractArray{Float64}; force::Bool=false)::Nothing::Nothing</code></pre><p>Adds a generated channel with <code>name</code>, <code>unit</code> and <code>data</code> to the <code>grid</code>. The <code>data</code> must be of the same size as channel data in the <code>grid</code>, i.e. <code>grid.points</code> x <code>grid.pixelsize...</code>. The <code>name</code> cannot be the same as names in the original channel names. If the <code>name</code> exists in the generated channel names, it will be overwritten. If <code>force</code> is <code>true</code>, then the consistency checks for name and dimensions are overriden.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L443-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.add_parameter!-Tuple{Function, SpmGrids.SpmGrid, AbstractString, AbstractString, Vararg{Any}}" href="#SpmGrids.add_parameter!-Tuple{Function, SpmGrids.SpmGrid, AbstractString, AbstractString, Vararg{Any}}"><code>SpmGrids.add_parameter!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_parameter!(func::Function, grid::SpmGrid, name::AbstractString, unit::AbstractString,
    args...::AbstractString; force::Bool=false)::Nothing</code></pre><p>Adds a generated parameter with <code>name</code>, <code>unit</code> and <code>data</code> to the <code>grid</code>. The parameter is generated by the function <code>func</code> that takes other parameter/channels specified by <code>args...</code> as input parameters. Any broadcasting functionality should be implemented in <code>func</code>. The <code>name</code> cannot be the same as names in the original parameter names. If the <code>name</code> exists in the generated parameter names, it will be overwritten. If <code>force</code> is <code>true</code>, then the consistency checks for name and dimensions are overriden.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; grid = load_grid(&quot;file.3ds&quot;)
julia&gt; add_parameter!(x -&gt; abs(x), grid, &quot;Scan:ExcitationAbs&quot;, &quot;V&quot;, &quot;Scan:Excitation&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L630-L647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.add_parameter!-Tuple{SpmGrids.SpmGrid, AbstractString, AbstractString, AbstractArray{Float64}}" href="#SpmGrids.add_parameter!-Tuple{SpmGrids.SpmGrid, AbstractString, AbstractString, AbstractArray{Float64}}"><code>SpmGrids.add_parameter!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_parameter!(grid::SpmGrid, name::AbstractString, unit::AbstractString,
    data::AbstractArray{Float64}; force::Bool=false)::Nothing</code></pre><p>Adds a generated parameter with <code>name</code>, <code>unit</code> and <code>data</code> to the <code>grid</code>. The <code>data</code> must be of the same size as parameter data in the <code>grid</code>, i.e. <code>grid.pixelsize</code>. The <code>name</code> cannot be the same as names in the original parameter names. If the <code>name</code> exists in the generated parameter names, it will be overwritten. If <code>force</code> is <code>true</code>, then the consistency checks for name and dimensions are overriden.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L598-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.channel_names-Tuple{SpmGrids.SpmGrid}" href="#SpmGrids.channel_names-Tuple{SpmGrids.SpmGrid}"><code>SpmGrids.channel_names</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">channel_names(grid::SpmGrid, skip_bwd=true)::Array{String}</code></pre><p>Returns all channel names in <code>grid</code>. If <code>skip_bwd</code> is <code>true</code>, then the channel names for the bwds direction are not returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L330-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.deconvolve_force!" href="#SpmGrids.deconvolve_force!"><code>SpmGrids.deconvolve_force!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deconvolve_force!(grid::SpmGrid, response_channel::String,
    f₀::Float64=0., A::Float64=0., k::Float64=1800.;
    sweep_channel::String=&quot;&quot;, bwd::Bool=true)::Nothing</code></pre><p>Applies the <a href="https://aip.scitation.org/doi/10.1063/1.1667267">Sadar Jarvis force deconvolution algorithm</a> as implemented in the <a href="https://github.com/alexriss/SpmSpectroscopy.jl">SpmSpectroscopy</a> package to each point in the <code>grid</code>. <code>response_channel</code> should refer to the &quot;Frequency Shift&quot; channel and <code>sweep_channel</code> (which defaults to the sweep signal of the grid) should be tip height &quot;Z&quot;.</p><p>In addition, the along the experimental parameters <code>f₀</code> (resonance frequency), <code>A</code> (oscillation amplitude), and <code>k</code> (cantilever stiffness) can be specified. For <code>k</code> the default values is 1800 N/m, which is a typical value for <a href="https://doi.org/10.1063/1.5052264">qPlus sensors</a>. If the values for <code>f₀</code> and <code>A</code> are left at their default values of <code>0.</code>, the values will be extracted from the header data.</p><p>Adds the channels <code>&quot;Force z&quot;</code> and <code>&quot;Potential&quot;</code> to the SpmGrid <code>grid</code>. Additionally, the channels <code>&quot;Force x&quot;</code> and <code>&quot;Force y&quot;</code> will be calculated by differentiation of the  Potential in x and y direction, respectively. The x and y force components will not be calculated if the <code>sweep_channel</code> is not sorted.</p><p>If <code>bwd</code> is <code>true</code> (default), the plot will include data from backward sweep as well (if they exist).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/domain_functions.jl#L115-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.fit_KPFM!-Tuple{SpmGrids.SpmGrid, String}" href="#SpmGrids.fit_KPFM!-Tuple{SpmGrids.SpmGrid, String}"><code>SpmGrids.fit_KPFM!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit_KPFM!(grid::SpmGrid, response_channel::String;
    sweep_channel::String=&quot;&quot;, bwd::Bool=true)::Nothing</code></pre><p>Fits KPFM data. This is done by fitting a parabola to the graoh of <code>response_channel</code> vs <code>sweep_channel</code> on the grid. If not explicitely specified, <code>sweep_channel</code> defaults to the sweep signal of the grid.</p><p>For KPFM, the response channel should be the &quot;Frequency Shift&quot; channel and the sweep channel is the &quot;Bias&quot;.</p><p>Adds the parameters <code>&quot;KPFM:Bias&quot;</code>, <code>&quot;KPFM:Frequency Shift&quot;</code>, <code>&quot;KPFM:Residuals AbsSum&quot;</code> and the channels <code>&quot;KPFM:Fit&quot;</code>, <code>&quot;KPFM:Residuals&quot;</code> to the SpmGrid <code>grid</code>.</p><p>If <code>bwd</code> is <code>true</code> (default), the plot will include data from backward sweep as well (if they exist).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/domain_functions.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.get_channel" href="#SpmGrids.get_channel"><code>SpmGrids.get_channel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_channel(grid::SpmGrid, name::AbstractString,
    x_index::GridRange=:, y_index::GridRange=:, channel_index::GridRange=:;
    bwd::Bool=false)::SubArray{Float64}</code></pre><p>Returns the data for the channel <code>name</code> at the point(s) specified by <code>x_index</code>, <code>y_index</code> The channel data can be indexed by <code>channel_index</code>. If <code>bwd</code> is <code>true</code>, the bwd channel is returned if it exists. If <code>view</code> is <code>true</code> (default), then a view(@ref Base.view) is returned , otherwise a copy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L395-L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.get_channel_unit-Tuple{SpmGrids.SpmGrid, AbstractString}" href="#SpmGrids.get_channel_unit-Tuple{SpmGrids.SpmGrid, AbstractString}"><code>SpmGrids.get_channel_unit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_channel_unit(grid::SpmGrid, name::AbstractString)::AbstractString</code></pre><p>Returns the unit associated with the channel <code>name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L378-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.get_data" href="#SpmGrids.get_data"><code>SpmGrids.get_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_data(grid::SpmGrid, name::AbstractString,
    x_index::GridRange=:, y_index::GridRange=:, channel_index::GridRange=:;
    bwd::Bool=false)::SubArray{Float64}</code></pre><p>Returns the data for the channel or parameter <code>name</code> at the point(s) specified by <code>x_index</code>, <code>y_index</code> Channel data can also be indexed by <code>channel_index</code>. If <code>bwd</code> is <code>true</code>, the bwd channel is returned if it exists. If <code>view</code> is <code>true</code> (default), then a view(@ref Base.view) is returned , otherwise a copy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L668-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.get_parameter" href="#SpmGrids.get_parameter"><code>SpmGrids.get_parameter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_parameter(grid::SpmGrid, name::AbstractString,
    x_index::GridRange=:, y_index::GridRange=:; view::Bool=true)::Union{Array{Float64},SubArray{Float64}}</code></pre><p>Returns the value for parameter <code>name</code> at the point(s)specified by <code>x_index</code>, <code>y_index</code>. If <code>view</code> is <code>true</code> (default), then a view(@ref Base.view) is returned , otherwise a copy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L566-L572">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.get_parameter_unit-Tuple{SpmGrids.SpmGrid, AbstractString}" href="#SpmGrids.get_parameter_unit-Tuple{SpmGrids.SpmGrid, AbstractString}"><code>SpmGrids.get_parameter_unit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_parameter_unit(grid::SpmGrid, name::AbstractString)::AbstractString</code></pre><p>Returns the unit associated with the parameter <code>name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L549-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.has_channel-Tuple{SpmGrids.SpmGrid, AbstractString}" href="#SpmGrids.has_channel-Tuple{SpmGrids.SpmGrid, AbstractString}"><code>SpmGrids.has_channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_channel(grid::SpmGrid, name::AbstractString; bwd::Bool=false)::Bool</code></pre><p>Returns <code>true</code> if channel <code>name</code> is present in the grid. If <code>bwd</code> is <code>true</code>, the checks for the existance of the bwd channel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L345-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.has_parameter-Tuple{SpmGrids.SpmGrid, AbstractString}" href="#SpmGrids.has_parameter-Tuple{SpmGrids.SpmGrid, AbstractString}"><code>SpmGrids.has_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_parameter(grid::SpmGrid, name::AbstractString)::Bool</code></pre><p>Returns <code>true</code> if parameter <code>name</code> is present in the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L525-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.interactive_display" href="#SpmGrids.interactive_display"><code>SpmGrids.interactive_display</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interactive_display(fname::String, response_channel::String=&quot;&quot;, response_channel2::String=&quot;&quot;, parameter::String=&quot;&quot;;
    bwd::Bool=false, fig::Any=nothing, backend::Module=Main, kwargs...)::Any</code></pre><p>Display the grid in an interactive GUI that can be used in Pluto, Jupyter, or other interactive environments. <code>response_channel</code> specifies the initial choice of the response channel, <code>response_channel2</code> specifies the initial choice of the response channel for the second line plot, <code>parameter</code> specifies the initial parameter to plot.</p><p>Before using this function, a <a href="https://makie.juliaplots.org/">Makie</a> backend (<code>GLMakie</code>, <code>CairoMakie</code> or <code>WGLMakie</code>) should be imported and the figure can be set up and passed via the <code>fig</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/interactive_functions.jl#L329-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.interactive_display" href="#SpmGrids.interactive_display"><code>SpmGrids.interactive_display</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interactive_display(grid::SpmGrid, response_channel::String=&quot;&quot;, response_channel2::String=&quot;&quot;, parameter::String=&quot;&quot;;
    bwd::Bool=false, fig::Any=nothing, backend::Module=Main)::Any</code></pre><p>Display the grid in an interactive GUI that can be used in Pluto, Jupyter, or other interactive environments. <code>response_channel</code> specifies the initial choice of the response channel, <code>response_channel2</code> specifies the initial choice of the response channel for the second line plot, <code>parameter</code> specifies the initial parameter to plot.</p><p>Before using this function, a <a href="https://makie.juliaplots.org/">Makie</a> backend (<code>GLMakie</code>, <code>CairoMakie</code> or <code>WGLMakie</code>) should be imported and the figure can be set up and passed via the <code>fig</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/interactive_functions.jl#L28-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.load_grid" href="#SpmGrids.load_grid"><code>SpmGrids.load_grid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_grid(images::Vector{&lt;:SpmImage}, by::Function=im -&gt; im.z
name::AbstractString=&quot;Z&quot;, unit::AbstractString=&quot;m&quot;;
only_overlap::Bool=false, header_only::Bool=false)::SpmGrid</code></pre><p>Loads a grid from a stack of images. The sweep signal is specified with the <code>by</code> argument, as well as <code>name</code> and <code>unit</code>. The first image determines the pixel density, as well as the channels that will be available. Here, the backward channels will be associated with the backward scan direciton in the images. Ideally, all images should have the same pixel density and recorded channels. if <code>only_overlap</code> is true, then data is returned only for the pixels that are overlapping in all images. If <code>header_only</code> is <code>true</code>, then only the header is created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/stack_functions.jl#L23-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.load_grid" href="#SpmGrids.load_grid"><code>SpmGrids.load_grid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_grid(filenames::Vector{&lt;:AbstractString}, by::Function=im-&gt;im.z,
    name::AbstractString=&quot;Z_&quot;, unit::AbstractString=&quot;m&quot;;
    only_overlap::Bool=false, header_only::Bool=false)::SpmGrid</code></pre><p>Loads a grid from a stack of image files. The sweep signal is specified with the <code>by</code> argument, as well as <code>name</code> and <code>unit</code>. The first image determines the pixel density, as well as the channels that will be available. Here, the backward channels will be associated with the backward scan direciton in the images. Ideally, all images should have the same pixel density and recorded channels. if <code>only_overlap</code> is true, then data is returned only for the pixels that are overlapping in all images. If <code>header_only</code> is <code>true</code>, then only the header is created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/stack_functions.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.load_grid-Tuple{AbstractString}" href="#SpmGrids.load_grid-Tuple{AbstractString}"><code>SpmGrids.load_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_grid(filename::AbstractString; header_only::Bool=false)</code></pre><p>Loads a grid from a binary file. If <code>header_only</code> is <code>true</code>, then only the header is loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.parameter_names-Tuple{SpmGrids.SpmGrid}" href="#SpmGrids.parameter_names-Tuple{SpmGrids.SpmGrid}"><code>SpmGrids.parameter_names</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameter_names(grid::SpmGrid)::Array{String}</code></pre><p>Returns all parameter names in <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L514-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.plot_cube" href="#SpmGrids.plot_cube"><code>SpmGrids.plot_cube</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_cube(grid::SpmGrid, response_channel::String,
    x_index::GridRange=:, y_index::GridRange=:, channel_index::GridRange=:;
    bwd::Bool=false, ax::Any=nothing, backend::Module=Main,
    kwargs...)::NamedTuple</code></pre><p>Plots a cube of <code>response_channel</code> in the three-dimensional data spanned by the x,y plane and the sweep signal. Indexing is done through <code>x_index</code>, <code>y_index</code> and <code>channel_index</code> and should be done such that a three-dimensional array is obtained. If <code>bwd</code> is set to <code>true</code>, then data from the backward sweep is plotted if it exists.</p><p>Before using this function, a <a href="https://makie.juliaplots.org/">Makie</a> backend (<code>GLMakie</code>, <code>CairoMakie</code> or <code>WGLMakie</code>) should be imported and the figure or axis should be set up. A particular Axis can be specified via the <code>ax</code> keyword argument. By default, the Makie backend from the <code>Main</code> module is used; it can also be directly specified via the <code>backend</code> keyword argument.</p><p>Extra keyword arguments can be specified and will be passed through to the plot function.</p><p>Returns a NamedTuple containing the volume-plot, and a colorbar label.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/plot_functions.jl#L933-L954">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.plot_cube-Tuple{NamedTuple, Any, Any, Module}" href="#SpmGrids.plot_cube-Tuple{NamedTuple, Any, Any, Module}"><code>SpmGrids.plot_cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_cube(data::NamedTuple, ax::Any, ax_cb::Any, backend::Module; kwargs...)::Nothing</code></pre><p>Plots a cube from the NamedTuple <code>data</code> on Axis <code>ax</code>. A colorbar is also plotted on <code>ax_cb</code>. A Makie backend should be given and extra keyword arguments can be provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/interactive_functions.jl#L428-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.plot_line" href="#SpmGrids.plot_line"><code>SpmGrids.plot_line</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_line(grid::SpmGrid, response_channel::String,
    x_index::GridRange, y_index::GridRange, channel_index::GridRange=nothing;
    sweep_channel::String=&quot;&quot;, bwd::Bool=true, ax::Any=nothing, backend::Module=Main,
    kwargs...)::NamedTuple</code></pre><p>Plots the <code>response_channel</code> along a line in the three-dimensional data spanned by x,y plane and the spectroscopy data. Indexing is done through <code>x_index</code>, <code>y_index</code> and <code>channel_index</code> and should be done such that a one-dimensional array is obtained. It is also possible to plot <code>response_channel</code> vs <code>sweep_channel</code> (which defaults to the sweep signal if not specified) for one point in the grid If <code>bwd</code> is <code>true</code> (default), the plot will include data from backward sweep as well (if they exist).</p><p>Before using this function, a <a href="https://makie.juliaplots.org/">Makie</a> backend (<code>GLMakie</code>, <code>CairoMakie</code> or <code>WGLMakie</code>) should be imported and the figure or axis should be set up. A particular Axis can be specified via the <code>ax</code> keyword argument. By default, the Makie backend from the <code>Main</code> module is used; it can also be directly specified via the <code>backend</code> keyword argument.</p><p>Extra keyword arguments can be specified and will be passed through to the plot function. Keyword arrguments with the suffix <code>_bwd</code> will be used for plotting of the backward scan.    </p><p>Returns a NamedTuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/plot_functions.jl#L488-L511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.plot_line-Tuple{NamedTuple, Any, Module}" href="#SpmGrids.plot_line-Tuple{NamedTuple, Any, Module}"><code>SpmGrids.plot_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_line(data::NamedTuple, ax::Any, backend::Module; bwd::Bool=true, kwargs...)::Nothing</code></pre><p>Plots a line from the NamedTuple <code>x</code> vs <code>y</code> and <code>x_bwd</code> vs <code>y_bwd</code> on Axis <code>ax</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/interactive_functions.jl#L379-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.plot_parameter_plane" href="#SpmGrids.plot_parameter_plane"><code>SpmGrids.plot_parameter_plane</code></a> — <span class="docstring-category">Function</span></header><section><div><p>plot<em>parameter</em>plane(grid::SpmGrid, parameter::String,         x<em>index::GridRange=:, y</em>index::GridRange=:;         ax::Any=nothing, backend::Module=Main,         kwargs...)::NamedTuple</p><p>Plots values of <code>parameters</code> as a function of the x,y plane Indexing is done through <code>x_index</code>, <code>y_index</code>.</p><p>Before using this function, a <a href="https://makie.juliaplots.org/">Makie</a> backend (<code>GLMakie</code>, <code>CairoMakie</code> or <code>WGLMakie</code>) should be imported and the figure or axis should be set up. A particular Axis can be specified via the <code>ax</code> keyword argument. By default, the Makie backend from the <code>Main</code> module is used; it can also be directly specified via the <code>backend</code> keyword argument.</p><p>Extra keyword arguments can be specified and will be passed through to the plot function.</p><p>Returns a NamedTuple containing the heatmap, the colorbar label and the plot label.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/plot_functions.jl#L609-L627">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.plot_plane" href="#SpmGrids.plot_plane"><code>SpmGrids.plot_plane</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_plane(grid::SpmGrid, response_channel::String,
    x_index::GridRange, y_index::GridRange, channel_index::GridRange=:;
    bwd::Bool=false, ax::Any=nothing, backend::Module=Main,
    kwargs...)::NamedTuple</code></pre><p>Plots a plane of <code>response_channel</code> in the three-dimensional data spanned by x,y plane and the sweep signal. Indexing is done through <code>x_index</code>, <code>y_index</code> and <code>channel_index</code> and should be done such that a two-dimensional array is obtained. If <code>bwd</code> is set to <code>true</code>, then data from the backward sweep is plotted if it exists.</p><p>Before using this function, a <a href="https://makie.juliaplots.org/">Makie</a> backend (<code>GLMakie</code>, <code>CairoMakie</code> or <code>WGLMakie</code>) should be imported and the figure or axis should be set up. A particular Axis can be specified via the <code>ax</code> keyword argument. By default, the Makie backend from the <code>Main</code> module is used; it can also be directly specified via the <code>backend</code> keyword argument.</p><p>Extra keyword arguments can be specified and will be passed through to the plot function.</p><p>Returns a NamedTuple containing the heatmap, the colorbar label and the plot label.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/plot_functions.jl#L778-L798">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.plot_plane-Tuple{NamedTuple, Any, Any, Module}" href="#SpmGrids.plot_plane-Tuple{NamedTuple, Any, Any, Module}"><code>SpmGrids.plot_plane</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_plane(data::NamedTuple, ax::Any, ax_cb::Any, backend::Module; kwargs...)::Nothing</code></pre><p>Plots a plane from the NamedTuple <code>data</code> on Axis <code>ax</code>. A colorbar is also plotted on <code>ax_cb</code>. A Makie backend should be given and extra keyword arguments can be provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/interactive_functions.jl#L403-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.plot_spectrum" href="#SpmGrids.plot_spectrum"><code>SpmGrids.plot_spectrum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_spectrum(grid::SpmGrid, sweep_channel::String, response_channel::String,
    x_index::GridRange, y_index::GridRange, channel_index::GridRange=:;
    bwd::Bool=true, ax::Any=nothing, backend::Module=Main,
    kwargs...)::NamedTuple</code></pre><p>Plots a line plot of <code>response_channel</code> vs <code>sweep_channel</code> on the given <code>x_index</code> and <code>y_index</code>. If <code>sweep_channel</code> is <code>&quot;&quot;</code>, then the sweep signal will be used for <code>sweep_channel</code>. Additionally, the spectrum data can be indexed by <code>channel_index</code>. If <code>bwd</code> is <code>true</code> (default), the plot will include data from backward sweep as well (if they exist).</p><p>Before using this function, a <a href="https://makie.juliaplots.org/">Makie</a> backend (<code>GLMakie</code>, <code>CairoMakie</code> or <code>WGLMakie</code>) should be imported and the figure or axis should be set up. A particular Axis can be specified via the <code>ax</code> keyword argument. By default, the Makie backend from the <code>Main</code> module is used; it can also be directly specified via the <code>backend</code> keyword argument.</p><p>Extra keyword arguments can be specified and will be passed through to the plot function. Keyword arrguments with the suffix <code>_bwd</code> will be used for plotting of the backward scan.</p><p>Returns a NamedTuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/plot_functions.jl#L253-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.point_to_xyindex-Tuple{SpmGrids.SpmGrid, Vector{Float64}}" href="#SpmGrids.point_to_xyindex-Tuple{SpmGrids.SpmGrid, Vector{Float64}}"><code>SpmGrids.point_to_xyindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_to_xyindex(grid::SpmGrid, point::Vector{Float64})::Tuple{Int,Int}</code></pre><p>Converts <code>point</code> (in physical units) of <code>grid</code> to index<em>x and index</em>y</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L713-L717">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpmGrids.xyindex_to_point-Tuple{SpmGrids.SpmGrid, Int64, Int64}" href="#SpmGrids.xyindex_to_point-Tuple{SpmGrids.SpmGrid, Int64, Int64}"><code>SpmGrids.xyindex_to_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xyindex_to_point(grid::SpmGrid, index_x::Int, index_y)::Tuple{Float64,Float64}</code></pre><p>Converts <code>index_x</code> and <code>index_y</code> of <code>grid</code> to point coordinates in physical units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alexriss/SpmGrids.jl/blob/9cc89353b242b9f1be5f548dd9e5ca30ad416730/src/SpmGrids.jl#L699-L703">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial_3/">« Tutorial 3: Real life</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 8 January 2023 18:59">Sunday 8 January 2023</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
